---
title: 'Developing a 2FA-CLI tool with C++'
---

Developing a 2FA-CLI tool with c++
===

## Table of Contents

[TOC]

## introduction

2 Factor Authentication (2FA) is becoming more and more popular to add an extra layer of security to accounts. One of the many methods to authenticate a user with a second factor would be token-based authentication. In the past 4 weeks I have developed an application written in C++ to generate login tokens. This document describes my research into 2FA, CLI tools and my journey to develop this application.

The idea is to store a shared secret on a trusted device. With this secret, and a parameter, a one time password can be generated. This parameter used to be a counter, but over time an adaptation on that algorithm was made to use a timestamp instead. As long as the device and the login server are synchronized on the same time, everything works as intended.


## 2FA
There are a lot of methods that can be used to implement 2FA. Possible methods are biometric authentication, a smart card, a hardware token, or an one time password (OTP). This document goes into detail about the One Time Passwords.

### HMAC-based One-Time Password (HOTP)
HOTP is the original One-Time Password algorithm, and relies on 2 pieces of information. The first is a secret key, the other is a number that changes everytime the server succesfully validated an OTP. This is called a moving factor. The tool that generates the OTP usually has a button that increments the counter.

A downside to this method is that the server and the token generator can easily get out of sync. For example, the button on the token generator can be pressed by accident, resulting in an invalid token. For this reason, the server will not only allow the OTP generated with counter N, but also for a set number of increments from the previous counter value. This is called the validation window. The bigger this window, the higher the chance that one of the OTP's can be guessed with a brute force attack.

### Time-based One-Time Password (TOTP)
TOTP is based on the HOTP algorithm, but the moving factor is not a counter, but instead the current time. A number will be generated from the current time. This means that the algorithm is the same. Because the current time is used, only 1 OTP is valid at any given time. The one generated from the current UNIX time.

### Algorithm explained
The algorithm to generate an OTP is described in RFC4226[^RFC4226] and RFC6238[^RFC6238]. In this chapter I am citing these steps to generate an OTP from these 2 documents.

#### Notation and Symbols
| symbol | Represents |
|---|---|
| $C$ | 8-byte counter value, the moving factor.  This counter MUST be synchronized between the HOTP generator (client) and the HOTP validator (server).|
| $K$ | shared secret between client and server; each HOTP generator has a different and unique secret K |
| $digit$ | number of digits in an HOTP value; system parameter |
| $Sbits$ | 4-byte string in binary representation |
| $Snum$ | the same 4-byte string, in decimal representation |
| $D$ | the OTP; number in the range $0...10^{digit}-1$ |

the HOTP and TOTP tokens rely on the HMAC-SHA-1 hashing function. This algorithm returns a 20-byte string ALWAYS. this is too long for easy use, therefore, this string needs to be truncated to a 4-byte string.

#### generating an HOTP value

1. Generate a hash $HS$ with the HMAC-SHA-I function
$HS = HMAC-SHA-1(K,C)$ 
HS is a 20-byte string `
2. Generate a 4-byte string with Dynamic Truncation ($DT()$)
$Sbits = DT(HS)$
DT, defined below, returns a 31-bit string
3. Compute an HOTP value
$Snum = StToNum(Sbits)$
Convert the binary represenation to a 32-bit integer.
return $D = Snum \mod{10^{digit}}$

note that:
- The key ($K$), the counter ($C$), and Data values are hashed high order first
- the HOTP values generated by the HOTP generator

#### Dynamic Truncation
The purpose of the dynamic offset truncation technique is to extract a 4-byte dynamic binary code from a 20-byte HMAC-SHA-1 result

1. the last byte of the hash refers denotes the offset $o$. The offset is a number in the range $0...15$
2. return the first 4 bytes, counting from the offset byte
$P = HS[o] ... HS[o+3]$
3. the sign bit should ALWAYS be 0. This is to avoid confusion about signed vs. unsigned modulo computations. Different processors perform these operations differntly. Masking out the signed bit removes all ambiguity.


#### Example of HOTP computation for $digit = 6$
The following example describes the Dynamic Truncation process followed by generating the 6 digit OTP.
```
   -------------------------------------------------------------
   | Byte Number                                               |
   -------------------------------------------------------------
   |00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|
   -------------------------------------------------------------
   | Byte Value                                                |
   -------------------------------------------------------------
   |1f|86|98|69|0e|02|ca|16|61|85|50|ef|7f|19|da|8e|94|5b|55|5a|
   -------------------------------**-**-**-**----------------++|
```

- The last byte (byte 19) has the hex value of `0x5a`
- The value of the lower 4 bits is `0xa` or `0d10`
- The value of the 4 bytes starting at the offset byte $10$ is `0x50ef7f19`
- mask the first byte with `0x7f`. This sets the first bit to 0, even if it was a 1 originally. In this case the number stays `0x50ef7f19`
- `0x50ef7f19` is `0d1357872921` 
- $OTP = 1357872921 \mod{10^6} = 872921$

## CLI
Command line interfaces can operate in a lot of different ways. There is not really a single standard to add extra options and arguments to a program. However, POSIX style is one of the more common ways to do this. Almost all basic linux utilities use this standard. However, there is no law that each linux program should run like this. This means that there are a lot of programs that operate in a different way.

### POSIX
POSIX specifies how the shell needs to operate, and what can be expected from certain shell commands. It also specifies which C libraries should be used. For this project I will mostly look at the specification for shell commands. Below is a list of the argument syntax of POSIX. [^posix_arguments] 
 * Arguments are posix_options if they begin with a hyphen delimiter (‘-’).
 * Multiple posix_options may follow a hyphen delimiter in a single token if the posix_options do not take arguments. Thus, ‘-abc’ is equivalent to ‘-a -b -c’.
 * Option names are single alphanumeric characters (as for isalnum; see Classification of Characters).
 * Certain posix_options require an argument. For example, the -o option of the ld command requires an argument—an output file name.
 * An option and its argument may or may not appear as separate tokens. (In other words, the whitespace separating them is optional.) Thus, -o foo and -ofoo are equivalent.
 * Options typically precede other non-option arguments.

For this project, I intend to follow this syntax as much as possible. However, I may not implement all of them. An example is the fifth one in the list. A whitespace is necessary to seperate an option from an argument. At the time of implementation this seemed to be something minor that would be too difficult to implement.

## Implementation
This chapter will be all about my implementation. During this project I had to work on 3 major parts to get to a working 2FA tool. I will explain some interesting parts of my code. The entire codebase will be available on my [github](https://github.com/MasterMaus/2FA_CLI).

### Input parsing
In order to add arguments and options to a executable, it is necessary to add 2 parameters in the main function. The signature of the function will become `int main(int argc, char *argv[]`. 
`argc` is the ammount of arguments added to the executable. 
`argv` contains all the different arguments that were added with the executable. The first argument will always be name of the executable itself.

To parse the arguments from the executable, I created an input parser. This is a different class that contains a map.
```c++=
std::map<posix_options::Options, std::vector<std::string> > m_options;
```
Each option found in the arguments are mapped with a vector of strings. This vector of strings are all the arguments that are passed with this option. An empty vector is passed if the option doesnt have any arguments.

Each possible option for the tool is defined in `Options.h`. This file contains an enum with possible options. It also contains a static map with relevant information and functions that execute each option.

<h5 a><strong><code>Options.h</code></strong></h5>

```c++=
namespace posix_options {

    enum Options {
        version, help, add, remove, generate,invalid
    };


    const static std::string D_HELP = "Display this help or a command specific help";
    /*  
    more strings like this
    */


    const static std::map<Options, std::tuple<std::string, char, bool, int, int, std::string> > OPTIONS {
            {version, {"version", 'v', true, 0, 0, D_VERSION}},
            {help, {"help", 'h', false, 0, 1, D_HELP}},
            {add, {"add", 'a', false, 2, 2, D_ADD}}, // actually might need max 3 args; id, secret, encoding
            {generate, {"generate", 'g', false, 1, 2, D_GENERATE}}
    };
    
    ...
```

The constructor of the input parser class takes the arguments from the main function. It makes a distinction between short option, long option, or argument by testing if the string starts with a dash. Whenever it finds an option, it checks if the option is supported. (all supported options should be defined in the map `OPTIONS` in `Options.h`).
It starts parsing all arguments after the option, until it reaches the maximum amount of arguments defined in `Options.h`. Whenever it reaches an option (starts with `-`) it breaks out of the loop immediately.
Out of the loop, it tests the amount of arguments with the definition. If the amount arguments are not correct, an exception is thrown.

<h5 a><strong><code>IputParser.h</code></strong></h5>


```c++=
if (arg.starts_with("--")) {
    // long option found
    posix_options::Options option = posix_options::find(arg.substr(2)); // take only the part after --
    
    std::vector<std::string> args = {};
    int min_args = std::get<MIN_ARG>(posix_options::OPTIONS.at(option));
    int max_args = std::get<MAX_ARG>(posix_options::OPTIONS.at(option));

    for (int a = 0; a < max_args; a++) {
        if (i+1 >= argc) {
            break; // no more arguments
        }
        auto argument = std::string(argv[i+1]); // this cant break, because we test if there is at least one more string
        if (argument.starts_with('-')) {
            // this is not an argument!!
            break;
        }
        args.push_back(argument);
        i++;
    }
    if (args.size() < min_args || args.size() > max_args) {
        throw exceptions::InvalidArgumentsException("not enough or too many arguments for this option!");
    }
     
     m_options[option] = args;

}

...
```
This code snippet is used when a long option is found, an option that starts with `--`. The code used for a short option is very similair. The only thing that is different is that it tests if the option is a flag or not. A flag cannot have any arguments. These options may be concatenated to 1 option. `-a -b -c` is the same as `-abc`. 

<h5 a><strong><code>IputParser.h</code></strong></h5>

```c++=
...
if (arg.size() !=2) {
    //flags
    for (auto c: arg) {
        if (c == '-') continue;

        posix_options::Options flag = posix_options::find(c);
        if (flag == posix_options::Options::invalid || !posix_options::isFlag(flag))
            throw exceptions::InvalidArgumentsException();

        m_options[flag] = {};
    }
} else ...
```
The rest of the code for short options is similair to the long options, and therefore not displayed in this report.

The last part of the constructor validates the input if not an option was found, but instead an argument. In this case, the default option will be used. In the case of this project, to generate a token for a specific ID. This may only happen at the very end of the arguments array.

<h5 a><strong><code>IputParser.h</code></strong></h5>

```c++=
...
{
    // default option (generate)
    posix_options::Options option = posix_options::Options::generate;

    std::vector<std::string> args = {};
    int min_args = std::get<MIN_ARG>(posix_options::OPTIONS.at(option));
    int max_args = std::get<MAX_ARG>(posix_options::OPTIONS.at(option));

    for (int a = 0; a < max_args; a++) {
        if (i >= argc) {
            break; // no more arguments
        }
        auto argument = std::string(argv[i]); // The thing on i is already an argument, not an option
        if (argument.starts_with('-')) {
            // this is not an argument!!
            break;
        }
        args.push_back(argument);
        i++;
    }
    if (args.size() < min_args || args.size() > max_args) {
        throw exceptions::InvalidArgumentsException("not enough or too many arguments for this option!");
    }

    m_options[option] = args;

    if (i < argc) {
        // there are still options or arguments, but this is illegal!
        throw exceptions::InvalidArgumentsException("Too many arguments!");
    }
}
```

### OTP code generation 
The second major part of this project would be the OTP code generation. Without the methods to do this, the tool would be useless. The part of the input parser would try to keep things as generic as possible, so that it can be used for a different CLI tool, this part is specifically for the 2FA tool.

[This part implements the algorithm explained earlier in this document](#Algorithm-explained). For the hashing I used a library I found on GitHub[^cryptlite] named cryptlite. I copied those headers into my project. This library has a dependency on Boost 1.45 . In order to make sure that it actually works I installed that version[^boost]. newer versions of boost are not always backwards compatible.

For the implementation of the OTP code generation, I created 2 files. 
1. TokenGenerator.cpp/h
2. Key.h

The first file contains some functions that glue the whole process of token generation together. For the most part it just does the relevant things from the cryptlite library. 
The second file is a class that contains relevant information to create tokens. 

<h5 a><strong><code>Key.h</code></strong></h5>

```c++=
private:
    std::string m_id;
    std::vector<uint8_t> m_key;
    bool m_totp = true; // in case of HOTP, set to false
    int m_ttl = 30; // Only relevant if TOTP is used, by default this is 30
    int m_otp_len = 6; // number of digits, by default this is 6
    long long m_counter = 0; // Only relevant if HOTP is used
```

For the implementation right now, its not really necessary to have this class. All of this could have been done in the main class as well. However, Doing it this way makes it easier to implement token generation with specific options. For example:
* OTP tokens with 8 numbers instead of 6
* OTP tokens with a different duration
* [HOTP tokens](#HMAC-based-One-Time-Password-HOTP)

The Key class contains different constructors some constructors to fill the member variables. Right now 2 different constructors have been implemented, but when the tool is extended, more constructors might be created.

The first constructor takes an ID, a secet, and possibly an encoding as its arguments. If no specific encoding is added, it will use the base32 encoding.

<h5 a><strong><code>Key.h</code></strong></h5>

```c++=
Key(const std::string id, const std::string secret, const encoding enc = encoding::B32) : m_id{std::move(id)} {
    switch (enc) {
        case encoding::B32 :
            m_key = b32::base32decode(std::move(secret));
            break;
        case encoding::B64 :
            throw exceptions::NotImplementedException();
            break;
        default :
            throw std::exception();
    }
}
```

This constructor is usually called by the program when a key is not yet in stored on the computer. In most cases, the user would like to actually store the key with its ID into a file. This will be handled in the last major part of implementation.

The second constructor takes an ID, and a path to a file. This constructor reads the file and tries to search for the corresponding key.

<h5 a><strong><code>Key.h</code></strong></h5>

```c++=
Key(const std::string id, const fs::path& path) : m_id{std::move(id)} {
    ...
}
```

To retrieve an OTP, the method getOTP() is called. This method calls a function in `TokenGenerator.h`. Depending on different options, different functions should be called from that file. However, for now, only the TOTP with 6 digits, and a lifespan of 30 seconds is implemented.

<h5 a><strong><code>Key.h</code></strong></h5>

```c++=
std::string getOTP() {
    if (m_totp) {
        // TOTP
        return token_generator::gen_OTP(m_key);
    } else {
        throw exceptions::NotImplementedException("Generating HOTP tokens is currently not yet implemented");
    }
}
```

### Reading and writing to a binary file to store and retrieve secret keys
The last major part of this project is storing and retrieving secret keys. Since these keys do not have to be human readable, it is most efficient to store those in a binary format. I thought of a format of my own. 
* Each entry starts with a prefix. This prefix needs to be here in order to seperate different keys. I chose a prefix of 3 bytes, filled with ones. or written in hex notation: `0xFFFFFF`.
* The next 2 bytes are flags. The first byte stores the byte length of the ID, and if there are extra options. Extra options are not yet implemented, but those might be in a later stage.
* The second flag stores the byte length of the secret key.
* The next `f1` bytes are reserved for the ID of the key.
* The next `f2` bytes are reserved for the secret.
* If the options bit is set, the last byte or bytes will be used to set different options. I still have to figure out a format for this, since I did not implement any of the options yet.

Below is an example of what an entry COULD look like.


binary file:
```
pf = prefix
f1 = flag 1 (special options (most significant bit), size of the id in bytes)
f2 = flag 2 (size of the secret key in bytes)
id = key identifier
sk = secret key
op = options byte(s)


-------------------------------------------------------------
| Byte Number                                               |
-------------------------------------------------------------
|00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|
-------------------------------------------------------------
| Byte Meaning                                              |
-------------------------------------------------------------
|pf|pf|pf|f1|f2|id|id|id|id|sk|sk|sk|sk|sk|sk|sk|sk|sk|sk|op|
-------------------------------------------------------------
| Byte Value (id = len 4), (key = len 10)                   |
-------------------------------------------------------------
|ff|ff|ff|04|0a|94|5b|55|5a|31|32|33|34|35|36|37|38|39|30|??|
------------------------------------------------------------|

```

For the current implementation I needed to create 2 functions. 1 function writes to an existing file (as binary). The other function reads that same file, and searches for an ID. If it finds the ID, it initializes the Key class [from the second part](#OTP-code-generation).

The first function writes binary data to some file, in the format that I invented.

<h5 a><strong><code>Key.h</code></strong></h5>


```c++=
void writeSecret(const fs::path& path) {
    std::ofstream file(path, std::ios::out | std::ios::binary | std::ios::app);

    char prefixSecret [3];
    prefixSecret[0] = (char) (PREFIX_NEW_SECRET >> 0);
    prefixSecret[1] = (char) (PREFIX_NEW_SECRET >> 8);
    prefixSecret[2] = (char) (PREFIX_NEW_SECRET >> 16);

    file.write((prefixSecret), 3);

    uint8_t flag1 = m_id.size();
    uint8_t flag2 = m_key.size();

    file.put((char) flag1); // posix_options bit + length of the key id in bytes
    file.put((char) flag2); // length of the secret in bytes

    file.write(m_id.c_str(),m_id.size());
    for(auto c : m_key) {
        file.put((char)c);
    }
    //todo think about implementing posix_options. like, HOTP, size of the token and time
}
```

The second function opens the file containing all the data. It sets the reader pointer to the start of the secret. (find the prefix). It then searches for the ID. If the IDs. are matching, it reads the secret, and stores it in the member variable. If not, it sets the reader pointer to the next secret same file. If the entire file has been searched, and no match has been found, an exception is thrown.

```c++=

static void nextSecret(std::ifstream &stream) {
    int count = 0;
    while (count != 3 && !stream.eof()) {
        if (stream.get() == 0xff) count++;
        else count = 0;
    }
}

...

Key(const std::string id, const fs::path& path) : m_id{std::move(id)} {
    std::ifstream file{path, std::ios::in | std::ios::binary};
    bool match = false;

    uint8_t key_len;

    while (!match) {
        nextSecret(file); // set read pointer to the start of the next secret
        if(file.eof()) break;
        uint8_t flag1 = file.get();
        key_len = file.get();

        if (flag1 >> 7 == 0x01) {
            // option flag has been set
            flag1 &= 0x7f;
            throw exceptions::NotImplementedException();
        }
        std::string name {};
        for (int i = 0; i < flag1; i++) {
            name += (char) file.get();
        }
        if (m_id == name) match = true;
    }

    if (match) {
        for (int i = 0; i < key_len; i++) {
            m_key.push_back(file.get());
        }
    } else {
        throw exceptions::NotImplementedException("Trying to fetch the secret for a non existant id");
    }
}
```


## Commands:
* Key generation (1 code):
* * `2fa saxion`
* * `2fa -g saxion`
* * `2fa --generate saxion`
* Add key
* * `2fa -a saxion supernotsosecretkey`
* * `2fa --add saxion supernotsosecretkey`
* HELP
* * `2fa -h`
* * `2fa --help`
* * `2fa -h [option]`
* * `2fa --help [option]`
* version
* * `2fa -v`
* * `2fa --version`

Interesting pipes to use with 2fa
* `2fa saxion | xclip -selection clipboard` (xclip is a program for X Window System. This program can copy stuff to clipboard)
* 


## Further development of the 2FA-CLI tool
The tool as is is working right now. A secret key can be added to the tool with the following command: `2fa -a saxion supernotsosecretkey`
An OTP can be generated with the command: `2fa saxion`
However, some things SHOULD be added to the tool still:
* Exception handling; this is not yet implemented. The exceptions should be caught, and a nice description should be displayed in terminal for the user
* Removing key from file by ID; this is not yet implemented. A secret key should be able to be removed from the data file. usage: `2fa -r saxion` or `2fa --remove saxion`
* The data file where secrets are stored should be encrypted.
* Extra options can be implemented. For example different Time To Live for the OTP, using more than 6 digits for the OTP or displaying the next `x` OTP codes.

The following things COULD be added:
* Export 1 or more secret keys to a super secret file that can be used to import those secret keys on another machine

## References
[^posix_arguments]: https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
[^RFC4226]: https://www.rfc-editor.org/rfc/rfc4226
[^RFC6238]: https://www.rfc-editor.org/rfc/rfc6238
[^cryptlite]: https://github.com/lyokato/cpp-cryptlite/
[^boost]: https://www.boost.org/doc/libs/1_81_0/more/getting_started/unix-variants.html